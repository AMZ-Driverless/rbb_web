// tslint:disable
/**
 * Rosbag Bazaar API
 * API to access the Rosbag Bazaar service
 *
 * OpenAPI spec version: 0.1.1
 * Contact: hhendrik@student.ethz.ch
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/api/v0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BagExtractionConfiguration
 */
export interface BagExtractionConfiguration {
    /**
     * Name of the configuration
     * @type {string}
     * @memberof BagExtractionConfiguration
     */
    name: string;
    /**
     * Description of this configuration
     * @type {string}
     * @memberof BagExtractionConfiguration
     */
    description: string;
    /**
     * Type of the configuration. (only git is supported now)
     * @type {string}
     * @memberof BagExtractionConfiguration
     */
    type: string;
    /**
     * Data that is specific to the configuration type.
     * @type {any}
     * @memberof BagExtractionConfiguration
     */
    config: any;
}

/**
 * 
 * @export
 * @interface BagStoreSummary
 */
export interface BagStoreSummary {
    /**
     * 
     * @type {string}
     * @memberof BagStoreSummary
     */
    detail_type: string;
    /**
     * 
     * @type {string}
     * @memberof BagStoreSummary
     */
    name: string;
}

/**
 * 
 * @export
 * @interface BagSummary
 */
export interface BagSummary {
    /**
     * 
     * @type {string}
     * @memberof BagSummary
     */
    detail_type: string;
    /**
     * 
     * @type {string}
     * @memberof BagSummary
     */
    name: string;
    /**
     * Data that is specific to the bag store type.
     * @type {any}
     * @memberof BagSummary
     */
    store_data: any;
    /**
     * Date and time this bag was discovered.
     * @type {Date}
     * @memberof BagSummary
     */
    discovered: Date;
    /**
     * True if the extraction failed
     * @type {boolean}
     * @memberof BagSummary
     */
    extraction_failure?: boolean;
    /**
     * True if the bag is in the trash bin.
     * @type {boolean}
     * @memberof BagSummary
     */
    in_trash?: boolean;
    /**
     * True if data is extracted from this bag.
     * @type {boolean}
     * @memberof BagSummary
     */
    is_extracted: boolean;
    /**
     * True if meta data is known for this bag.
     * @type {boolean}
     * @memberof BagSummary
     */
    meta_available: boolean;
    /**
     * Size of the bag in bytes.
     * @type {number}
     * @memberof BagSummary
     */
    size?: number;
    /**
     * Start time of this bag.
     * @type {Date}
     * @memberof BagSummary
     */
    start_time?: Date;
    /**
     * Start time of this bag.
     * @type {Date}
     * @memberof BagSummary
     */
    end_time?: Date;
    /**
     * duration of this bag in seconds.
     * @type {number}
     * @memberof BagSummary
     */
    duration?: number;
    /**
     * Number of messages in this bag.
     * @type {number}
     * @memberof BagSummary
     */
    messages?: number;
    /**
     * 
     * @type {Array&lt;Tag&gt;}
     * @memberof BagSummary
     */
    tags?: Array<Tag>;
}

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    identifier: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    comment_text: string;
    /**
     * 
     * @type {Date}
     * @memberof Comment
     */
    created: Date;
    /**
     * 
     * @type {User}
     * @memberof Comment
     */
    posted_by?: User;
}

/**
 * 
 * @export
 * @interface FileStore
 */
export interface FileStore {
    /**
     * Name of the store
     * @type {string}
     * @memberof FileStore
     */
    name: string;
    /**
     * Type of store.
     * @type {string}
     * @memberof FileStore
     */
    store_type: string;
    /**
     * Data that is specific to the store type.
     * @type {any}
     * @memberof FileStore
     */
    store_data: any;
    /**
     * Date and time this store was added to the bazaar.
     * @type {Date}
     * @memberof FileStore
     */
    created: Date;
}

/**
 * 
 * @export
 * @interface FileSummary
 */
export interface FileSummary {
    /**
     * 
     * @type {string}
     * @memberof FileSummary
     */
    detail_type: string;
    /**
     * Name of the file store
     * @type {string}
     * @memberof FileSummary
     */
    store_name: string;
    /**
     * Unique file id
     * @type {number}
     * @memberof FileSummary
     */
    uid?: number;
    /**
     * Name of the file
     * @type {string}
     * @memberof FileSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FileSummary
     */
    link?: string;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    fields?: string;
}

/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    identifier: string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    granted?: boolean;
}

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    uid: string;
    /**
     * Plugin that created this product
     * @type {string}
     * @memberof Product
     */
    plugin: string;
    /**
     * Type of product
     * @type {string}
     * @memberof Product
     */
    product_type: string;
    /**
     * Product data
     * @type {any}
     * @memberof Product
     */
    product_data: any;
    /**
     * Date and time this product was created.
     * @type {Date}
     * @memberof Product
     */
    created: Date;
    /**
     * Some descriptive title
     * @type {string}
     * @memberof Product
     */
    title?: string;
    /**
     * Tag of the configuration file that generated this product
     * @type {string}
     * @memberof Product
     */
    configuration_tag?: string;
    /**
     * Name of the rule that generated this product
     * @type {string}
     * @memberof Product
     */
    configuration_rule?: string;
    /**
     * 
     * @type {Array&lt;TopicMapping&gt;}
     * @memberof Product
     */
    topics: Array<TopicMapping>;
    /**
     * 
     * @type {Array&lt;ProductFile&gt;}
     * @memberof Product
     */
    files: Array<ProductFile>;
}

/**
 * 
 * @export
 * @interface ProductFile
 */
export interface ProductFile {
    /**
     * Key that links the file to the product
     * @type {string}
     * @memberof ProductFile
     */
    key?: string;
    /**
     * 
     * @type {FileSummary}
     * @memberof ProductFile
     */
    file?: FileSummary;
}

/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * Start time of this bag.
     * @type {Date}
     * @memberof Session
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    id?: number;
    /**
     * Only set on initial creation of a session
     * @type {string}
     * @memberof Session
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface SimulationEnvironmentSummary
 */
export interface SimulationEnvironmentSummary {
    /**
     * 
     * @type {string}
     * @memberof SimulationEnvironmentSummary
     */
    detail_type: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationEnvironmentSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationEnvironmentSummary
     */
    module_name: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationEnvironmentSummary
     */
    rosbag_store?: string;
}

/**
 * 
 * @export
 * @interface SimulationRunSummary
 */
export interface SimulationRunSummary {
    /**
     * 
     * @type {string}
     * @memberof SimulationRunSummary
     */
    detail_type: string;
    /**
     * 
     * @type {number}
     * @memberof SimulationRunSummary
     */
    identifier: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimulationRunSummary
     */
    success: boolean;
    /**
     * 
     * @type {string}
     * @memberof SimulationRunSummary
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof SimulationRunSummary
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof SimulationRunSummary
     */
    bag_name?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationRunSummary
     */
    bag_store_name?: string;
}

/**
 * 
 * @export
 * @interface SimulationSummary
 */
export interface SimulationSummary {
    /**
     * 
     * @type {string}
     * @memberof SimulationSummary
     */
    detail_type: string;
    /**
     * 
     * @type {number}
     * @memberof SimulationSummary
     */
    identifier: number;
    /**
     * 
     * @type {string}
     * @memberof SimulationSummary
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof SimulationSummary
     */
    created: Date;
    /**
     * 0 is scheduled, -1 is prep failed, -100 is sim failed, 100 is sim succeeded
     * @type {number}
     * @memberof SimulationSummary
     */
    result: number;
    /**
     * Name of the simulation environment
     * @type {string}
     * @memberof SimulationSummary
     */
    environment_name: string;
    /**
     * Identifier of the task associated to this simulation
     * @type {string}
     * @memberof SimulationSummary
     */
    queued_task_identifier?: string;
    /**
     * Read only value, taken from associated task
     * @type {number}
     * @memberof SimulationSummary
     */
    queued_task_state?: number;
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    tag: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    color: string;
}

/**
 * 
 * @export
 * @interface TaskSummary
 */
export interface TaskSummary {
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    detail_type: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    identifier: string;
    /**
     * 
     * @type {number}
     * @memberof TaskSummary
     */
    priority: number;
    /**
     * Simple description to identify the type of task
     * @type {string}
     * @memberof TaskSummary
     */
    description: string;
    /**
     * Name of worker assigned to the task.
     * @type {string}
     * @memberof TaskSummary
     */
    assigned_to: string;
    /**
     * Date the task was added to the queue.
     * @type {Date}
     * @memberof TaskSummary
     */
    created: Date;
    /**
     * Date the task was updated to the queue.
     * @type {Date}
     * @memberof TaskSummary
     */
    last_updated: Date;
    /**
     * State of the task.
     * @type {number}
     * @memberof TaskSummary
     */
    state: number;
    /**
     * The task.
     * @type {string}
     * @memberof TaskSummary
     */
    task: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskSummary
     */
    success: boolean;
    /**
     * 
     * @type {number}
     * @memberof TaskSummary
     */
    runtime: number;
    /**
     * Worker that can take this task.
     * @type {string}
     * @memberof TaskSummary
     */
    worker_labels: string;
}

/**
 * 
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * Name of the topic
     * @type {string}
     * @memberof Topic
     */
    name: string;
    /**
     * Message type of the topic
     * @type {string}
     * @memberof Topic
     */
    msg_type: string;
    /**
     * Hash identifier of the message type
     * @type {string}
     * @memberof Topic
     */
    msg_type_hash: string;
    /**
     * Definition of custom messages.
     * @type {string}
     * @memberof Topic
     */
    msg_definition?: string;
    /**
     * Number of messages in this topic.
     * @type {number}
     * @memberof Topic
     */
    msg_count: number;
    /**
     * Average publishing frequency
     * @type {number}
     * @memberof Topic
     */
    avg_frequency: number;
}

/**
 * 
 * @export
 * @interface TopicMapping
 */
export interface TopicMapping {
    /**
     * The name of the original topic
     * @type {string}
     * @memberof TopicMapping
     */
    original_topic: string;
    /**
     * Plugin topic name
     * @type {string}
     * @memberof TopicMapping
     */
    plugin_topic: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    alias?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    full_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {Array&lt;Permission&gt;}
     * @memberof User
     */
    permissions?: Array<Permission>;
    /**
     * Only set for changing password, otherwise empty.
     * @type {string}
     * @memberof User
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface BagDetailed
 */
export interface BagDetailed extends BagSummary {
    /**
     * 
     * @type {Array&lt;Topic&gt;}
     * @memberof BagDetailed
     */
    topics: Array<Topic>;
    /**
     * 
     * @type {Array&lt;Product&gt;}
     * @memberof BagDetailed
     */
    products: Array<Product>;
    /**
     * Manual comment on the bag.
     * @type {string}
     * @memberof BagDetailed
     */
    comment: string;
}

/**
 * 
 * @export
 * @interface BagStoreDetailed
 */
export interface BagStoreDetailed extends BagStoreSummary {
    /**
     * More information about this store.
     * @type {string}
     * @memberof BagStoreDetailed
     */
    description: string;
    /**
     * Type of store.
     * @type {string}
     * @memberof BagStoreDetailed
     */
    store_type: string;
    /**
     * Data that is specific to the store type.
     * @type {any}
     * @memberof BagStoreDetailed
     */
    store_data: any;
    /**
     * Date and time this store was added to the bazaar.
     * @type {Date}
     * @memberof BagStoreDetailed
     */
    created: Date;
    /**
     * Name of the default file store (empty if no default store)
     * @type {string}
     * @memberof BagStoreDetailed
     */
    default_file_store: string;
}

/**
 * 
 * @export
 * @interface FileDetailed
 */
export interface FileDetailed extends FileSummary {
    /**
     * Store specific data
     * @type {any}
     * @memberof FileDetailed
     */
    store_data: any;
}

/**
 * 
 * @export
 * @interface SimulationDetailed
 */
export interface SimulationDetailed extends SimulationSummary {
    /**
     * Configuration of the simulation.
     * @type {any}
     * @memberof SimulationDetailed
     */
    config: any;
    /**
     * Action to take when simulation completes.
     * @type {any}
     * @memberof SimulationDetailed
     */
    on_complete_action?: any;
    /**
     * Read only value, expanded on request.
     * @type {SimulationEnvironmentDetailed}
     * @memberof SimulationDetailed
     */
    environment?: SimulationEnvironmentDetailed;
    /**
     * Read only value, expanded on request.
     * @type {Array&lt;SimulationRunDetailed&gt;}
     * @memberof SimulationDetailed
     */
    runs?: Array<SimulationRunDetailed>;
    /**
     * Read only value, expanded on request.
     * @type {TaskDetailed}
     * @memberof SimulationDetailed
     */
    queued_task?: TaskDetailed;
}

/**
 * 
 * @export
 * @interface SimulationEnvironmentDetailed
 */
export interface SimulationEnvironmentDetailed extends SimulationEnvironmentSummary {
    /**
     * Configuration of the simulation environment.
     * @type {any}
     * @memberof SimulationEnvironmentDetailed
     */
    config: any;
    /**
     * Example simulation configuration shown in the simulation overview
     * @type {string}
     * @memberof SimulationEnvironmentDetailed
     */
    example_config: string;
}

/**
 * 
 * @export
 * @interface SimulationRunDetailed
 */
export interface SimulationRunDetailed extends SimulationRunSummary {
    /**
     * Configuration of the simulation.
     * @type {any}
     * @memberof SimulationRunDetailed
     */
    results: any;
    /**
     * Read only value, expanded on request.
     * @type {BagSummary}
     * @memberof SimulationRunDetailed
     */
    bag?: BagSummary;
}

/**
 * 
 * @export
 * @interface TaskDetailed
 */
export interface TaskDetailed extends TaskSummary {
    /**
     * Configuration of the task.
     * @type {any}
     * @memberof TaskDetailed
     */
    config?: any;
    /**
     * Result of the task
     * @type {any}
     * @memberof TaskDetailed
     */
    result?: any;
    /**
     * Standard output of the task
     * @type {string}
     * @memberof TaskDetailed
     */
    log?: string;
}


/**
 * BasicApi - fetch parameter creator
 * @export
 */
export const BasicApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeStepGet(store_name: string, step: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling authorizeStepGet.');
            }
            // verify required parameter 'step' is not null or undefined
            if (step === null || step === undefined) {
                throw new RequiredError('step','Required parameter step was null or undefined when calling authorizeStepGet.');
            }
            const localVarPath = `/file-storage/{store_name}/authorize/{step}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeStepPost(store_name: string, step: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling authorizeStepPost.');
            }
            // verify required parameter 'step' is not null or undefined
            if (step === null || step === undefined) {
                throw new RequiredError('step','Required parameter step was null or undefined when calling authorizeStepPost.');
            }
            const localVarPath = `/file-storage/{store_name}/authorize/{step}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bagStoreAuthorizeStepGet(store_name: string, step: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling bagStoreAuthorizeStepGet.');
            }
            // verify required parameter 'step' is not null or undefined
            if (step === null || step === undefined) {
                throw new RequiredError('step','Required parameter step was null or undefined when calling bagStoreAuthorizeStepGet.');
            }
            const localVarPath = `/stores/{store_name}/authorize/{step}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bagStoreAuthorizeStepPost(store_name: string, step: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling bagStoreAuthorizeStepPost.');
            }
            // verify required parameter 'step' is not null or undefined
            if (step === null || step === undefined) {
                throw new RequiredError('step','Required parameter step was null or undefined when calling bagStoreAuthorizeStepPost.');
            }
            const localVarPath = `/stores/{store_name}/authorize/{step}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {number} comment_id Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBagComment(store_name: string, bag_name: string, comment_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling deleteBagComment.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling deleteBagComment.');
            }
            // verify required parameter 'comment_id' is not null or undefined
            if (comment_id === null || comment_id === undefined) {
                throw new RequiredError('comment_id','Required parameter comment_id was null or undefined when calling deleteBagComment.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/comments/{comment_id}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(comment_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete extraction configuration
         * @param {string} config_name Name of the configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExtractionConfiguration(config_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'config_name' is not null or undefined
            if (config_name === null || config_name === undefined) {
                throw new RequiredError('config_name','Required parameter config_name was null or undefined when calling deleteExtractionConfiguration.');
            }
            const localVarPath = `/extraction/configs/{config_name}`
                .replace(`{${"config_name"}}`, encodeURIComponent(String(config_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete file store
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileStore(store_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling deleteFileStore.');
            }
            const localVarPath = `/file-storage/{store_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a session or sessions
         * @param {string} session_id Session id or all or current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(session_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'session_id' is not null or undefined
            if (session_id === null || session_id === undefined) {
                throw new RequiredError('session_id','Required parameter session_id was null or undefined when calling deleteSession.');
            }
            const localVarPath = `/sessions/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(session_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete simulation
         * @param {number} sim_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulation(sim_identifier: number, options: any = {}): FetchArgs {
            // verify required parameter 'sim_identifier' is not null or undefined
            if (sim_identifier === null || sim_identifier === undefined) {
                throw new RequiredError('sim_identifier','Required parameter sim_identifier was null or undefined when calling deleteSimulation.');
            }
            const localVarPath = `/simulations/{sim_identifier}`
                .replace(`{${"sim_identifier"}}`, encodeURIComponent(String(sim_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete simulation
         * @param {string} env_name Name of the simulation environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulationEnvironment(env_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'env_name' is not null or undefined
            if (env_name === null || env_name === undefined) {
                throw new RequiredError('env_name','Required parameter env_name was null or undefined when calling deleteSimulationEnvironment.');
            }
            const localVarPath = `/simulation-environments/{env_name}`
                .replace(`{${"env_name"}}`, encodeURIComponent(String(env_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete file store
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStore(store_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling deleteStore.');
            }
            const localVarPath = `/stores/{store_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user account
         * @param {string} alias Alias of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAccount(alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling deleteUserAccount.');
            }
            const localVarPath = `/users/account/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Take a task from the queue
         * @param {string} worker_name Name of the worker trying to acquire a task
         * @param {string} tasks Tasks that the worker can do (any or a list of tasks)
         * @param {string} labels Labels the worker wants to do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dequeueTask(worker_name: string, tasks: string, labels: string, options: any = {}): FetchArgs {
            // verify required parameter 'worker_name' is not null or undefined
            if (worker_name === null || worker_name === undefined) {
                throw new RequiredError('worker_name','Required parameter worker_name was null or undefined when calling dequeueTask.');
            }
            // verify required parameter 'tasks' is not null or undefined
            if (tasks === null || tasks === undefined) {
                throw new RequiredError('tasks','Required parameter tasks was null or undefined when calling dequeueTask.');
            }
            // verify required parameter 'labels' is not null or undefined
            if (labels === null || labels === undefined) {
                throw new RequiredError('labels','Required parameter labels was null or undefined when calling dequeueTask.');
            }
            const localVarPath = `/queue/dequeue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (worker_name !== undefined) {
                localVarQueryParameter['worker_name'] = worker_name;
            }

            if (tasks !== undefined) {
                localVarQueryParameter['tasks'] = tasks;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform an action on the task
         * @param {string} task_identifier 
         * @param {string} action Action to perform (cancel/prio_up)
         * @param {TaskDetailed} [task] The task, required depending on the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doTaskAction(task_identifier: string, action: string, task?: TaskDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'task_identifier' is not null or undefined
            if (task_identifier === null || task_identifier === undefined) {
                throw new RequiredError('task_identifier','Required parameter task_identifier was null or undefined when calling doTaskAction.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling doTaskAction.');
            }
            const localVarPath = `/queue/{task_identifier}`
                .replace(`{${"task_identifier"}}`, encodeURIComponent(String(task_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(task || {}) : (task || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List comments from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagComments(store_name: string, bag_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getBagComments.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling getBagComments.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/comments`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get rosbag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagFile(store_name: string, bag_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getBagFile.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling getBagFile.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List products from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagMeta(store_name: string, bag_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getBagMeta.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling getBagMeta.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/meta`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tag from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagTags(store_name: string, bag_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getBagTags.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling getBagTags.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/tags`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get configuration key
         * @param {string} config_key Configuration key to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationKey(config_key: string, options: any = {}): FetchArgs {
            // verify required parameter 'config_key' is not null or undefined
            if (config_key === null || config_key === undefined) {
                throw new RequiredError('config_key','Required parameter config_key was null or undefined when calling getConfigurationKey.');
            }
            const localVarPath = `/configuration/{config_key}`
                .replace(`{${"config_key"}}`, encodeURIComponent(String(config_key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Endpoint that should be periodically triggered
         * @param {string} [jobs] Specific cron jobs to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronEndpoint(jobs?: string, options: any = {}): FetchArgs {
            const localVarPath = `/cron`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jobs !== undefined) {
                localVarQueryParameter['jobs'] = jobs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get configuration details
         * @param {string} config_name Name of the configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtractionConfig(config_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'config_name' is not null or undefined
            if (config_name === null || config_name === undefined) {
                throw new RequiredError('config_name','Required parameter config_name was null or undefined when calling getExtractionConfig.');
            }
            const localVarPath = `/extraction/configs/{config_name}`
                .replace(`{${"config_name"}}`, encodeURIComponent(String(config_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get file
         * @param {string} store_name Name of the store
         * @param {number} uid Unique identifier of the file
         * @param {string} file_name Name of the file
         * @param {boolean} [no_redirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(store_name: string, uid: number, file_name: string, no_redirect?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getFile.');
            }
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getFile.');
            }
            // verify required parameter 'file_name' is not null or undefined
            if (file_name === null || file_name === undefined) {
                throw new RequiredError('file_name','Required parameter file_name was null or undefined when calling getFile.');
            }
            const localVarPath = `/file-storage/{store_name}/{uid}/{file_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"file_name"}}`, encodeURIComponent(String(file_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (no_redirect !== undefined) {
                localVarQueryParameter['no_redirect'] = no_redirect;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get file meta data
         * @param {string} store_name Name of the store
         * @param {number} uid Unique identifier of the file
         * @param {string} file_name Name of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(store_name: string, uid: number, file_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getFileMeta.');
            }
            // verify required parameter 'uid' is not null or undefined
            if (uid === null || uid === undefined) {
                throw new RequiredError('uid','Required parameter uid was null or undefined when calling getFileMeta.');
            }
            // verify required parameter 'file_name' is not null or undefined
            if (file_name === null || file_name === undefined) {
                throw new RequiredError('file_name','Required parameter file_name was null or undefined when calling getFileMeta.');
            }
            const localVarPath = `/file-storage/{store_name}/{uid}/{file_name}/meta`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"file_name"}}`, encodeURIComponent(String(file_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store details
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStore(store_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getFileStore.');
            }
            const localVarPath = `/file-storage/{store_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get simulation
         * @param {number} sim_identifier 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(sim_identifier: number, expand?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'sim_identifier' is not null or undefined
            if (sim_identifier === null || sim_identifier === undefined) {
                throw new RequiredError('sim_identifier','Required parameter sim_identifier was null or undefined when calling getSimulation.');
            }
            const localVarPath = `/simulations/{sim_identifier}`
                .replace(`{${"sim_identifier"}}`, encodeURIComponent(String(sim_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get simulation environment
         * @param {string} env_name Name of the simulation environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationEnvironment(env_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'env_name' is not null or undefined
            if (env_name === null || env_name === undefined) {
                throw new RequiredError('env_name','Required parameter env_name was null or undefined when calling getSimulationEnvironment.');
            }
            const localVarPath = `/simulation-environments/{env_name}`
                .replace(`{${"env_name"}}`, encodeURIComponent(String(env_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get simulation run
         * @param {number} sim_identifier 
         * @param {number} run_identifier 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationRun(sim_identifier: number, run_identifier: number, expand?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'sim_identifier' is not null or undefined
            if (sim_identifier === null || sim_identifier === undefined) {
                throw new RequiredError('sim_identifier','Required parameter sim_identifier was null or undefined when calling getSimulationRun.');
            }
            // verify required parameter 'run_identifier' is not null or undefined
            if (run_identifier === null || run_identifier === undefined) {
                throw new RequiredError('run_identifier','Required parameter run_identifier was null or undefined when calling getSimulationRun.');
            }
            const localVarPath = `/simulations/{sim_identifier}/runs/{run_identifier}`
                .replace(`{${"sim_identifier"}}`, encodeURIComponent(String(sim_identifier)))
                .replace(`{${"run_identifier"}}`, encodeURIComponent(String(run_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get store details
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore(store_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getStore.');
            }
            const localVarPath = `/stores/{store_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of auto extraction configs
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreExtractionConfigs(store_name: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling getStoreExtractionConfigs.');
            }
            const localVarPath = `/stores/{store_name}/auto-extraction-configs`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tag info
         * @param {string} tag Name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getTag.');
            }
            const localVarPath = `/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Take a task from the queue
         * @param {string} task_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(task_identifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'task_identifier' is not null or undefined
            if (task_identifier === null || task_identifier === undefined) {
                throw new RequiredError('task_identifier','Required parameter task_identifier was null or undefined when calling getTask.');
            }
            const localVarPath = `/queue/{task_identifier}`
                .replace(`{${"task_identifier"}}`, encodeURIComponent(String(task_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user information
         * @param {string} alias Alias of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccount(alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling getUserAccount.');
            }
            const localVarPath = `/users/account/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bags in store
         * @param {string} store_name Name of the store
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {Date} [discovered_gte] 
         * @param {Date} [discovered_lte] 
         * @param {Date} [start_time_gte] 
         * @param {Date} [start_time_lte] 
         * @param {Date} [end_time_gte] 
         * @param {Date} [end_time_lte] 
         * @param {number} [duration_gte] 
         * @param {number} [duration_lte] 
         * @param {boolean} [meta_available] 
         * @param {boolean} [is_extracted] 
         * @param {string} [name] 
         * @param {string} [tags] 
         * @param {boolean} [in_trash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBags(store_name: string, limit?: number, offset?: number, ordering?: string, discovered_gte?: Date, discovered_lte?: Date, start_time_gte?: Date, start_time_lte?: Date, end_time_gte?: Date, end_time_lte?: Date, duration_gte?: number, duration_lte?: number, meta_available?: boolean, is_extracted?: boolean, name?: string, tags?: string, in_trash?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling listBags.');
            }
            const localVarPath = `/stores/{store_name}/bags`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (discovered_gte !== undefined) {
                localVarQueryParameter['discovered_gte'] = (discovered_gte as any).toISOString();
            }

            if (discovered_lte !== undefined) {
                localVarQueryParameter['discovered_lte'] = (discovered_lte as any).toISOString();
            }

            if (start_time_gte !== undefined) {
                localVarQueryParameter['start_time_gte'] = (start_time_gte as any).toISOString();
            }

            if (start_time_lte !== undefined) {
                localVarQueryParameter['start_time_lte'] = (start_time_lte as any).toISOString();
            }

            if (end_time_gte !== undefined) {
                localVarQueryParameter['end_time_gte'] = (end_time_gte as any).toISOString();
            }

            if (end_time_lte !== undefined) {
                localVarQueryParameter['end_time_lte'] = (end_time_lte as any).toISOString();
            }

            if (duration_gte !== undefined) {
                localVarQueryParameter['duration_gte'] = duration_gte;
            }

            if (duration_lte !== undefined) {
                localVarQueryParameter['duration_lte'] = duration_lte;
            }

            if (meta_available !== undefined) {
                localVarQueryParameter['meta_available'] = meta_available;
            }

            if (is_extracted !== undefined) {
                localVarQueryParameter['is_extracted'] = is_extracted;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (in_trash !== undefined) {
                localVarQueryParameter['in_trash'] = in_trash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExtractionConfigurations(options: any = {}): FetchArgs {
            const localVarPath = `/extraction/configs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available file stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFileStores(options: any = {}): FetchArgs {
            const localVarPath = `/file-storage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List task queue
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {string} [running] Include running tasks, default is true
         * @param {string} [finished] Include finished tasks, default is true
         * @param {string} [queued] Include queued tasks, default is true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueue(limit?: number, offset?: number, ordering?: string, running?: string, finished?: string, queued?: string, options: any = {}): FetchArgs {
            const localVarPath = `/queue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (running !== undefined) {
                localVarQueryParameter['running'] = running;
            }

            if (finished !== undefined) {
                localVarQueryParameter['finished'] = finished;
            }

            if (queued !== undefined) {
                localVarQueryParameter['queued'] = queued;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessions(options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available simulation environments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulationEnvironments(options: any = {}): FetchArgs {
            const localVarPath = `/simulation-environments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List simulation runs
         * @param {number} sim_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulationRuns(sim_identifier: number, options: any = {}): FetchArgs {
            // verify required parameter 'sim_identifier' is not null or undefined
            if (sim_identifier === null || sim_identifier === undefined) {
                throw new RequiredError('sim_identifier','Required parameter sim_identifier was null or undefined when calling listSimulationRuns.');
            }
            const localVarPath = `/simulations/{sim_identifier}/runs`
                .replace(`{${"sim_identifier"}}`, encodeURIComponent(String(sim_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List simulations
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(limit?: number, offset?: number, ordering?: string, options: any = {}): FetchArgs {
            const localVarPath = `/simulations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStores(options: any = {}): FetchArgs {
            const localVarPath = `/stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options: any = {}): FetchArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user acounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts(options: any = {}): FetchArgs {
            const localVarPath = `/users/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary New bag comment
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {Comment} comment Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newBagComment(store_name: string, bag_name: string, comment: Comment, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling newBagComment.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling newBagComment.');
            }
            // verify required parameter 'comment' is not null or undefined
            if (comment === null || comment === undefined) {
                throw new RequiredError('comment','Required parameter comment was null or undefined when calling newBagComment.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/comments`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Comment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(comment || {}) : (comment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register new file
         * @param {string} store_name Name of the store
         * @param {FileDetailed} file The file metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newFile(store_name: string, file: FileDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling newFile.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling newFile.');
            }
            const localVarPath = `/file-storage/{store_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FileDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(file || {}) : (file || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new session
         * @param {number} [valid_for] Validity in seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession(valid_for?: number, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (valid_for !== undefined) {
                localVarQueryParameter['valid_for'] = valid_for;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary New simulation
         * @param {SimulationDetailed} simulation Simulation
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSimulation(simulation: SimulationDetailed, trigger?: string, options: any = {}): FetchArgs {
            // verify required parameter 'simulation' is not null or undefined
            if (simulation === null || simulation === undefined) {
                throw new RequiredError('simulation','Required parameter simulation was null or undefined when calling newSimulation.');
            }
            const localVarPath = `/simulations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (trigger !== undefined) {
                localVarQueryParameter['trigger'] = trigger;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SimulationDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(simulation || {}) : (simulation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary New simulation run
         * @param {number} sim_identifier 
         * @param {SimulationRunDetailed} simulation_run Simulation run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSimulationRun(sim_identifier: number, simulation_run: SimulationRunDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'sim_identifier' is not null or undefined
            if (sim_identifier === null || sim_identifier === undefined) {
                throw new RequiredError('sim_identifier','Required parameter sim_identifier was null or undefined when calling newSimulationRun.');
            }
            // verify required parameter 'simulation_run' is not null or undefined
            if (simulation_run === null || simulation_run === undefined) {
                throw new RequiredError('simulation_run','Required parameter simulation_run was null or undefined when calling newSimulationRun.');
            }
            const localVarPath = `/simulations/{sim_identifier}/runs`
                .replace(`{${"sim_identifier"}}`, encodeURIComponent(String(sim_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SimulationRunDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(simulation_run || {}) : (simulation_run || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskDetailed} task The task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newTask(task: TaskDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling newTask.');
            }
            const localVarPath = `/queue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(task || {}) : (task || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial update of bag information (this only supports a few fields)
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {any} bag Bag to register
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBagMeta(store_name: string, bag_name: string, bag: any, trigger?: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling patchBagMeta.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling patchBagMeta.');
            }
            // verify required parameter 'bag' is not null or undefined
            if (bag === null || bag === undefined) {
                throw new RequiredError('bag','Required parameter bag was null or undefined when calling patchBagMeta.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/meta`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (trigger !== undefined) {
                localVarQueryParameter['trigger'] = trigger;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bag || {}) : (bag || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partial update of task (this only supports a few fields)
         * @param {string} task_identifier 
         * @param {any} task Fields to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTask(task_identifier: string, task: any, options: any = {}): FetchArgs {
            // verify required parameter 'task_identifier' is not null or undefined
            if (task_identifier === null || task_identifier === undefined) {
                throw new RequiredError('task_identifier','Required parameter task_identifier was null or undefined when calling patchTask.');
            }
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling patchTask.');
            }
            const localVarPath = `/queue/{task_identifier}`
                .replace(`{${"task_identifier"}}`, encodeURIComponent(String(task_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(task || {}) : (task || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update bag information
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {BagDetailed} bag Bag to register
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBagMeta(store_name: string, bag_name: string, bag: BagDetailed, trigger?: string, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling putBagMeta.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling putBagMeta.');
            }
            // verify required parameter 'bag' is not null or undefined
            if (bag === null || bag === undefined) {
                throw new RequiredError('bag','Required parameter bag was null or undefined when calling putBagMeta.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/meta`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (trigger !== undefined) {
                localVarQueryParameter['trigger'] = trigger;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BagDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bag || {}) : (bag || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change bag tags
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {Array&lt;string&gt;} tags List of tags
         * @param {boolean} [auto_create] Create non existing tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBagTags(store_name: string, bag_name: string, tags: Array<string>, auto_create?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling putBagTags.');
            }
            // verify required parameter 'bag_name' is not null or undefined
            if (bag_name === null || bag_name === undefined) {
                throw new RequiredError('bag_name','Required parameter bag_name was null or undefined when calling putBagTags.');
            }
            // verify required parameter 'tags' is not null or undefined
            if (tags === null || tags === undefined) {
                throw new RequiredError('tags','Required parameter tags was null or undefined when calling putBagTags.');
            }
            const localVarPath = `/stores/{store_name}/bags/{bag_name}/tags`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)))
                .replace(`{${"bag_name"}}`, encodeURIComponent(String(bag_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (auto_create !== undefined) {
                localVarQueryParameter['auto_create'] = auto_create;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tags || {}) : (tags || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Write configuration key
         * @param {string} config_key Configuration key to read
         * @param {string} config_value Configuration key value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConfigurationKey(config_key: string, config_value: string, options: any = {}): FetchArgs {
            // verify required parameter 'config_key' is not null or undefined
            if (config_key === null || config_key === undefined) {
                throw new RequiredError('config_key','Required parameter config_key was null or undefined when calling putConfigurationKey.');
            }
            // verify required parameter 'config_value' is not null or undefined
            if (config_value === null || config_value === undefined) {
                throw new RequiredError('config_value','Required parameter config_value was null or undefined when calling putConfigurationKey.');
            }
            const localVarPath = `/configuration/{config_key}`
                .replace(`{${"config_key"}}`, encodeURIComponent(String(config_key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(config_value || {}) : (config_value || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change current user information
         * @param {User} user The user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentUser(user: User, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling putCurrentUser.');
            }
            const localVarPath = `/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update configuration
         * @param {string} config_name Name of the configuration
         * @param {BagExtractionConfiguration} configuration_obj Configuration information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExtractionConfiguration(config_name: string, configuration_obj: BagExtractionConfiguration, block_on_existing?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'config_name' is not null or undefined
            if (config_name === null || config_name === undefined) {
                throw new RequiredError('config_name','Required parameter config_name was null or undefined when calling putExtractionConfiguration.');
            }
            // verify required parameter 'configuration_obj' is not null or undefined
            if (configuration_obj === null || configuration_obj === undefined) {
                throw new RequiredError('configuration_obj','Required parameter configuration_obj was null or undefined when calling putExtractionConfiguration.');
            }
            const localVarPath = `/extraction/configs/{config_name}`
                .replace(`{${"config_name"}}`, encodeURIComponent(String(config_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (block_on_existing !== undefined) {
                localVarQueryParameter['block_on_existing'] = block_on_existing;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BagExtractionConfiguration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(configuration_obj || {}) : (configuration_obj || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {FileStore} store Store information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileStore(store_name: string, store: FileStore, block_on_existing?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling putFileStore.');
            }
            // verify required parameter 'store' is not null or undefined
            if (store === null || store === undefined) {
                throw new RequiredError('store','Required parameter store was null or undefined when calling putFileStore.');
            }
            const localVarPath = `/file-storage/{store_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (block_on_existing !== undefined) {
                localVarQueryParameter['block_on_existing'] = block_on_existing;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FileStore" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(store || {}) : (store || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a simulation
         * @param {number} sim_identifier 
         * @param {SimulationDetailed} simulation Simulation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimulation(sim_identifier: number, simulation: SimulationDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'sim_identifier' is not null or undefined
            if (sim_identifier === null || sim_identifier === undefined) {
                throw new RequiredError('sim_identifier','Required parameter sim_identifier was null or undefined when calling putSimulation.');
            }
            // verify required parameter 'simulation' is not null or undefined
            if (simulation === null || simulation === undefined) {
                throw new RequiredError('simulation','Required parameter simulation was null or undefined when calling putSimulation.');
            }
            const localVarPath = `/simulations/{sim_identifier}`
                .replace(`{${"sim_identifier"}}`, encodeURIComponent(String(sim_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SimulationDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(simulation || {}) : (simulation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update a simulation environment
         * @param {string} env_name Name of the simulation environment
         * @param {SimulationEnvironmentDetailed} environment Simulation environment
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimulationEnvironment(env_name: string, environment: SimulationEnvironmentDetailed, block_on_existing?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'env_name' is not null or undefined
            if (env_name === null || env_name === undefined) {
                throw new RequiredError('env_name','Required parameter env_name was null or undefined when calling putSimulationEnvironment.');
            }
            // verify required parameter 'environment' is not null or undefined
            if (environment === null || environment === undefined) {
                throw new RequiredError('environment','Required parameter environment was null or undefined when calling putSimulationEnvironment.');
            }
            const localVarPath = `/simulation-environments/{env_name}`
                .replace(`{${"env_name"}}`, encodeURIComponent(String(env_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (block_on_existing !== undefined) {
                localVarQueryParameter['block_on_existing'] = block_on_existing;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SimulationEnvironmentDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(environment || {}) : (environment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {BagStoreDetailed} store Store information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStore(store_name: string, store: BagStoreDetailed, block_on_existing?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling putStore.');
            }
            // verify required parameter 'store' is not null or undefined
            if (store === null || store === undefined) {
                throw new RequiredError('store','Required parameter store was null or undefined when calling putStore.');
            }
            const localVarPath = `/stores/{store_name}`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (block_on_existing !== undefined) {
                localVarQueryParameter['block_on_existing'] = block_on_existing;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BagStoreDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(store || {}) : (store || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {Array&lt;string&gt;} config_list List of config names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStoreExtractionConfigs(store_name: string, config_list: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'store_name' is not null or undefined
            if (store_name === null || store_name === undefined) {
                throw new RequiredError('store_name','Required parameter store_name was null or undefined when calling putStoreExtractionConfigs.');
            }
            // verify required parameter 'config_list' is not null or undefined
            if (config_list === null || config_list === undefined) {
                throw new RequiredError('config_list','Required parameter config_list was null or undefined when calling putStoreExtractionConfigs.');
            }
            const localVarPath = `/stores/{store_name}/auto-extraction-configs`
                .replace(`{${"store_name"}}`, encodeURIComponent(String(store_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(config_list || {}) : (config_list || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update tag
         * @param {string} tag Name of the tag
         * @param {Tag} tag_obj Tag information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTag(tag: string, tag_obj: Tag, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling putTag.');
            }
            // verify required parameter 'tag_obj' is not null or undefined
            if (tag_obj === null || tag_obj === undefined) {
                throw new RequiredError('tag_obj','Required parameter tag_obj was null or undefined when calling putTag.');
            }
            const localVarPath = `/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tag_obj || {}) : (tag_obj || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a task
         * @param {string} task_identifier 
         * @param {TaskDetailed} task The task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTask(task_identifier: string, task: TaskDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'task_identifier' is not null or undefined
            if (task_identifier === null || task_identifier === undefined) {
                throw new RequiredError('task_identifier','Required parameter task_identifier was null or undefined when calling putTask.');
            }
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling putTask.');
            }
            const localVarPath = `/queue/{task_identifier}`
                .replace(`{${"task_identifier"}}`, encodeURIComponent(String(task_identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(task || {}) : (task || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change user information
         * @param {string} alias Alias of the user
         * @param {User} user The user information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserAccount(alias: string, user: User, block_on_existing?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling putUserAccount.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling putUserAccount.');
            }
            const localVarPath = `/users/account/{alias}`
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (block_on_existing !== undefined) {
                localVarQueryParameter['block_on_existing'] = block_on_existing;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicApi - functional programming interface
 * @export
 */
export const BasicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeStepGet(store_name: string, step: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).authorizeStepGet(store_name, step, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeStepPost(store_name: string, step: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).authorizeStepPost(store_name, step, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bagStoreAuthorizeStepGet(store_name: string, step: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).bagStoreAuthorizeStepGet(store_name, step, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bagStoreAuthorizeStepPost(store_name: string, step: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).bagStoreAuthorizeStepPost(store_name, step, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {number} comment_id Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBagComment(store_name: string, bag_name: string, comment_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteBagComment(store_name, bag_name, comment_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete extraction configuration
         * @param {string} config_name Name of the configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExtractionConfiguration(config_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteExtractionConfiguration(config_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete file store
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileStore(store_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteFileStore(store_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a session or sessions
         * @param {string} session_id Session id or all or current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(session_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteSession(session_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete simulation
         * @param {number} sim_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulation(sim_identifier: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteSimulation(sim_identifier, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete simulation
         * @param {string} env_name Name of the simulation environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulationEnvironment(env_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteSimulationEnvironment(env_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete file store
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStore(store_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteStore(store_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete user account
         * @param {string} alias Alias of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAccount(alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).deleteUserAccount(alias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Take a task from the queue
         * @param {string} worker_name Name of the worker trying to acquire a task
         * @param {string} tasks Tasks that the worker can do (any or a list of tasks)
         * @param {string} labels Labels the worker wants to do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dequeueTask(worker_name: string, tasks: string, labels: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaskDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).dequeueTask(worker_name, tasks, labels, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Perform an action on the task
         * @param {string} task_identifier 
         * @param {string} action Action to perform (cancel/prio_up)
         * @param {TaskDetailed} [task] The task, required depending on the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doTaskAction(task_identifier: string, action: string, task?: TaskDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaskDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).doTaskAction(task_identifier, action, task, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List comments from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagComments(store_name: string, bag_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Comment>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getBagComments(store_name, bag_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get rosbag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagFile(store_name: string, bag_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getBagFile(store_name, bag_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List products from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagMeta(store_name: string, bag_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BagDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getBagMeta(store_name, bag_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List tag from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagTags(store_name: string, bag_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tag>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getBagTags(store_name, bag_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get configuration key
         * @param {string} config_key Configuration key to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationKey(config_key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getConfigurationKey(config_key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Endpoint that should be periodically triggered
         * @param {string} [jobs] Specific cron jobs to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronEndpoint(jobs?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getCronEndpoint(jobs, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getCurrentUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get configuration details
         * @param {string} config_name Name of the configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtractionConfig(config_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BagExtractionConfiguration> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getExtractionConfig(config_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get file
         * @param {string} store_name Name of the store
         * @param {number} uid Unique identifier of the file
         * @param {string} file_name Name of the file
         * @param {boolean} [no_redirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(store_name: string, uid: number, file_name: string, no_redirect?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getFile(store_name, uid, file_name, no_redirect, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get file meta data
         * @param {string} store_name Name of the store
         * @param {number} uid Unique identifier of the file
         * @param {string} file_name Name of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(store_name: string, uid: number, file_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getFileMeta(store_name, uid, file_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get store details
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStore(store_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileStore> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getFileStore(store_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get simulation
         * @param {number} sim_identifier 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(sim_identifier: number, expand?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getSimulation(sim_identifier, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get simulation environment
         * @param {string} env_name Name of the simulation environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationEnvironment(env_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationEnvironmentDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getSimulationEnvironment(env_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get simulation run
         * @param {number} sim_identifier 
         * @param {number} run_identifier 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationRun(sim_identifier: number, run_identifier: number, expand?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationRunDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getSimulationRun(sim_identifier, run_identifier, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get store details
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore(store_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BagStoreDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getStore(store_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get list of auto extraction configs
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreExtractionConfigs(store_name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BagExtractionConfiguration>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getStoreExtractionConfigs(store_name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get tag info
         * @param {string} tag Name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getTag(tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Take a task from the queue
         * @param {string} task_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(task_identifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaskDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getTask(task_identifier, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user information
         * @param {string} alias Alias of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccount(alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).getUserAccount(alias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bags in store
         * @param {string} store_name Name of the store
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {Date} [discovered_gte] 
         * @param {Date} [discovered_lte] 
         * @param {Date} [start_time_gte] 
         * @param {Date} [start_time_lte] 
         * @param {Date} [end_time_gte] 
         * @param {Date} [end_time_lte] 
         * @param {number} [duration_gte] 
         * @param {number} [duration_lte] 
         * @param {boolean} [meta_available] 
         * @param {boolean} [is_extracted] 
         * @param {string} [name] 
         * @param {string} [tags] 
         * @param {boolean} [in_trash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBags(store_name: string, limit?: number, offset?: number, ordering?: string, discovered_gte?: Date, discovered_lte?: Date, start_time_gte?: Date, start_time_lte?: Date, end_time_gte?: Date, end_time_lte?: Date, duration_gte?: number, duration_lte?: number, meta_available?: boolean, is_extracted?: boolean, name?: string, tags?: string, in_trash?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BagSummary>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listBags(store_name, limit, offset, ordering, discovered_gte, discovered_lte, start_time_gte, start_time_lte, end_time_gte, end_time_lte, duration_gte, duration_lte, meta_available, is_extracted, name, tags, in_trash, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List available configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExtractionConfigurations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BagExtractionConfiguration>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listExtractionConfigurations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List available file stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFileStores(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FileStore>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listFileStores(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List task queue
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {string} [running] Include running tasks, default is true
         * @param {string} [finished] Include finished tasks, default is true
         * @param {string} [queued] Include queued tasks, default is true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueue(limit?: number, offset?: number, ordering?: string, running?: string, finished?: string, queued?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TaskSummary>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listQueue(limit, offset, ordering, running, finished, queued, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Session>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listSessions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List available simulation environments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulationEnvironments(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimulationEnvironmentSummary>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listSimulationEnvironments(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List simulation runs
         * @param {number} sim_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulationRuns(sim_identifier: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimulationRunSummary>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listSimulationRuns(sim_identifier, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List simulations
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(limit?: number, offset?: number, ordering?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimulationSummary>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listSimulations(limit, offset, ordering, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List available stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStores(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BagStoreDetailed>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listStores(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tag>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listTags(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List user acounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).listUserAccounts(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary New bag comment
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {Comment} comment Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newBagComment(store_name: string, bag_name: string, comment: Comment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comment> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).newBagComment(store_name, bag_name, comment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Register new file
         * @param {string} store_name Name of the store
         * @param {FileDetailed} file The file metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newFile(store_name: string, file: FileDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).newFile(store_name, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new session
         * @param {number} [valid_for] Validity in seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession(valid_for?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).newSession(valid_for, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary New simulation
         * @param {SimulationDetailed} simulation Simulation
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSimulation(simulation: SimulationDetailed, trigger?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).newSimulation(simulation, trigger, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary New simulation run
         * @param {number} sim_identifier 
         * @param {SimulationRunDetailed} simulation_run Simulation run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSimulationRun(sim_identifier: number, simulation_run: SimulationRunDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationRunDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).newSimulationRun(sim_identifier, simulation_run, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskDetailed} task The task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newTask(task: TaskDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaskDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).newTask(task, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Partial update of bag information (this only supports a few fields)
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {any} bag Bag to register
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBagMeta(store_name: string, bag_name: string, bag: any, trigger?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BagDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).patchBagMeta(store_name, bag_name, bag, trigger, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Partial update of task (this only supports a few fields)
         * @param {string} task_identifier 
         * @param {any} task Fields to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTask(task_identifier: string, task: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaskDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).patchTask(task_identifier, task, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/update bag information
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {BagDetailed} bag Bag to register
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBagMeta(store_name: string, bag_name: string, bag: BagDetailed, trigger?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BagDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putBagMeta(store_name, bag_name, bag, trigger, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Change bag tags
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {Array&lt;string&gt;} tags List of tags
         * @param {boolean} [auto_create] Create non existing tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBagTags(store_name: string, bag_name: string, tags: Array<string>, auto_create?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tag>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putBagTags(store_name, bag_name, tags, auto_create, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Write configuration key
         * @param {string} config_key Configuration key to read
         * @param {string} config_value Configuration key value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConfigurationKey(config_key: string, config_value: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putConfigurationKey(config_key, config_value, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Change current user information
         * @param {User} user The user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentUser(user: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putCurrentUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/update configuration
         * @param {string} config_name Name of the configuration
         * @param {BagExtractionConfiguration} configuration_obj Configuration information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExtractionConfiguration(config_name: string, configuration_obj: BagExtractionConfiguration, block_on_existing?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BagExtractionConfiguration> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putExtractionConfiguration(config_name, configuration_obj, block_on_existing, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {FileStore} store Store information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileStore(store_name: string, store: FileStore, block_on_existing?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileStore> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putFileStore(store_name, store, block_on_existing, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a simulation
         * @param {number} sim_identifier 
         * @param {SimulationDetailed} simulation Simulation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimulation(sim_identifier: number, simulation: SimulationDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putSimulation(sim_identifier, simulation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/update a simulation environment
         * @param {string} env_name Name of the simulation environment
         * @param {SimulationEnvironmentDetailed} environment Simulation environment
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimulationEnvironment(env_name: string, environment: SimulationEnvironmentDetailed, block_on_existing?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationEnvironmentDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putSimulationEnvironment(env_name, environment, block_on_existing, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {BagStoreDetailed} store Store information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStore(store_name: string, store: BagStoreDetailed, block_on_existing?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BagStoreDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putStore(store_name, store, block_on_existing, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {Array&lt;string&gt;} config_list List of config names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStoreExtractionConfigs(store_name: string, config_list: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putStoreExtractionConfigs(store_name, config_list, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/update tag
         * @param {string} tag Name of the tag
         * @param {Tag} tag_obj Tag information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTag(tag: string, tag_obj: Tag, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putTag(tag, tag_obj, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a task
         * @param {string} task_identifier 
         * @param {TaskDetailed} task The task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTask(task_identifier: string, task: TaskDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaskDetailed> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putTask(task_identifier, task, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Change user information
         * @param {string} alias Alias of the user
         * @param {User} user The user information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserAccount(alias: string, user: User, block_on_existing?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = BasicApiFetchParamCreator(configuration).putUserAccount(alias, user, block_on_existing, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicApi - factory interface
 * @export
 */
export const BasicApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeStepGet(store_name: string, step: string, options?: any) {
            return BasicApiFp(configuration).authorizeStepGet(store_name, step, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeStepPost(store_name: string, step: string, options?: any) {
            return BasicApiFp(configuration).authorizeStepPost(store_name, step, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bagStoreAuthorizeStepGet(store_name: string, step: string, options?: any) {
            return BasicApiFp(configuration).bagStoreAuthorizeStepGet(store_name, step, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Authorization step forwarded to storage plugin
         * @param {string} store_name Name of the store
         * @param {string} step Step of the authorization procedure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bagStoreAuthorizeStepPost(store_name: string, step: string, options?: any) {
            return BasicApiFp(configuration).bagStoreAuthorizeStepPost(store_name, step, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {number} comment_id Comment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBagComment(store_name: string, bag_name: string, comment_id: number, options?: any) {
            return BasicApiFp(configuration).deleteBagComment(store_name, bag_name, comment_id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete extraction configuration
         * @param {string} config_name Name of the configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExtractionConfiguration(config_name: string, options?: any) {
            return BasicApiFp(configuration).deleteExtractionConfiguration(config_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete file store
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileStore(store_name: string, options?: any) {
            return BasicApiFp(configuration).deleteFileStore(store_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a session or sessions
         * @param {string} session_id Session id or all or current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(session_id: string, options?: any) {
            return BasicApiFp(configuration).deleteSession(session_id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete simulation
         * @param {number} sim_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulation(sim_identifier: number, options?: any) {
            return BasicApiFp(configuration).deleteSimulation(sim_identifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete simulation
         * @param {string} env_name Name of the simulation environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulationEnvironment(env_name: string, options?: any) {
            return BasicApiFp(configuration).deleteSimulationEnvironment(env_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete file store
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStore(store_name: string, options?: any) {
            return BasicApiFp(configuration).deleteStore(store_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete user account
         * @param {string} alias Alias of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAccount(alias: string, options?: any) {
            return BasicApiFp(configuration).deleteUserAccount(alias, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Take a task from the queue
         * @param {string} worker_name Name of the worker trying to acquire a task
         * @param {string} tasks Tasks that the worker can do (any or a list of tasks)
         * @param {string} labels Labels the worker wants to do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dequeueTask(worker_name: string, tasks: string, labels: string, options?: any) {
            return BasicApiFp(configuration).dequeueTask(worker_name, tasks, labels, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Perform an action on the task
         * @param {string} task_identifier 
         * @param {string} action Action to perform (cancel/prio_up)
         * @param {TaskDetailed} [task] The task, required depending on the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doTaskAction(task_identifier: string, action: string, task?: TaskDetailed, options?: any) {
            return BasicApiFp(configuration).doTaskAction(task_identifier, action, task, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List comments from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagComments(store_name: string, bag_name: string, options?: any) {
            return BasicApiFp(configuration).getBagComments(store_name, bag_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get rosbag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagFile(store_name: string, bag_name: string, options?: any) {
            return BasicApiFp(configuration).getBagFile(store_name, bag_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List products from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagMeta(store_name: string, bag_name: string, options?: any) {
            return BasicApiFp(configuration).getBagMeta(store_name, bag_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List tag from bag
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBagTags(store_name: string, bag_name: string, options?: any) {
            return BasicApiFp(configuration).getBagTags(store_name, bag_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get configuration key
         * @param {string} config_key Configuration key to read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationKey(config_key: string, options?: any) {
            return BasicApiFp(configuration).getConfigurationKey(config_key, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Endpoint that should be periodically triggered
         * @param {string} [jobs] Specific cron jobs to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCronEndpoint(jobs?: string, options?: any) {
            return BasicApiFp(configuration).getCronEndpoint(jobs, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any) {
            return BasicApiFp(configuration).getCurrentUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get configuration details
         * @param {string} config_name Name of the configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtractionConfig(config_name: string, options?: any) {
            return BasicApiFp(configuration).getExtractionConfig(config_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get file
         * @param {string} store_name Name of the store
         * @param {number} uid Unique identifier of the file
         * @param {string} file_name Name of the file
         * @param {boolean} [no_redirect] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(store_name: string, uid: number, file_name: string, no_redirect?: boolean, options?: any) {
            return BasicApiFp(configuration).getFile(store_name, uid, file_name, no_redirect, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get file meta data
         * @param {string} store_name Name of the store
         * @param {number} uid Unique identifier of the file
         * @param {string} file_name Name of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(store_name: string, uid: number, file_name: string, options?: any) {
            return BasicApiFp(configuration).getFileMeta(store_name, uid, file_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get store details
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileStore(store_name: string, options?: any) {
            return BasicApiFp(configuration).getFileStore(store_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get simulation
         * @param {number} sim_identifier 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(sim_identifier: number, expand?: boolean, options?: any) {
            return BasicApiFp(configuration).getSimulation(sim_identifier, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get simulation environment
         * @param {string} env_name Name of the simulation environment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationEnvironment(env_name: string, options?: any) {
            return BasicApiFp(configuration).getSimulationEnvironment(env_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get simulation run
         * @param {number} sim_identifier 
         * @param {number} run_identifier 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationRun(sim_identifier: number, run_identifier: number, expand?: boolean, options?: any) {
            return BasicApiFp(configuration).getSimulationRun(sim_identifier, run_identifier, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get store details
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore(store_name: string, options?: any) {
            return BasicApiFp(configuration).getStore(store_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get list of auto extraction configs
         * @param {string} store_name Name of the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreExtractionConfigs(store_name: string, options?: any) {
            return BasicApiFp(configuration).getStoreExtractionConfigs(store_name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get tag info
         * @param {string} tag Name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tag: string, options?: any) {
            return BasicApiFp(configuration).getTag(tag, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Take a task from the queue
         * @param {string} task_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(task_identifier: string, options?: any) {
            return BasicApiFp(configuration).getTask(task_identifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user information
         * @param {string} alias Alias of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccount(alias: string, options?: any) {
            return BasicApiFp(configuration).getUserAccount(alias, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bags in store
         * @param {string} store_name Name of the store
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {Date} [discovered_gte] 
         * @param {Date} [discovered_lte] 
         * @param {Date} [start_time_gte] 
         * @param {Date} [start_time_lte] 
         * @param {Date} [end_time_gte] 
         * @param {Date} [end_time_lte] 
         * @param {number} [duration_gte] 
         * @param {number} [duration_lte] 
         * @param {boolean} [meta_available] 
         * @param {boolean} [is_extracted] 
         * @param {string} [name] 
         * @param {string} [tags] 
         * @param {boolean} [in_trash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBags(store_name: string, limit?: number, offset?: number, ordering?: string, discovered_gte?: Date, discovered_lte?: Date, start_time_gte?: Date, start_time_lte?: Date, end_time_gte?: Date, end_time_lte?: Date, duration_gte?: number, duration_lte?: number, meta_available?: boolean, is_extracted?: boolean, name?: string, tags?: string, in_trash?: boolean, options?: any) {
            return BasicApiFp(configuration).listBags(store_name, limit, offset, ordering, discovered_gte, discovered_lte, start_time_gte, start_time_lte, end_time_gte, end_time_lte, duration_gte, duration_lte, meta_available, is_extracted, name, tags, in_trash, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List available configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExtractionConfigurations(options?: any) {
            return BasicApiFp(configuration).listExtractionConfigurations(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List available file stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFileStores(options?: any) {
            return BasicApiFp(configuration).listFileStores(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List task queue
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {string} [running] Include running tasks, default is true
         * @param {string} [finished] Include finished tasks, default is true
         * @param {string} [queued] Include queued tasks, default is true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueue(limit?: number, offset?: number, ordering?: string, running?: string, finished?: string, queued?: string, options?: any) {
            return BasicApiFp(configuration).listQueue(limit, offset, ordering, running, finished, queued, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSessions(options?: any) {
            return BasicApiFp(configuration).listSessions(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List available simulation environments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulationEnvironments(options?: any) {
            return BasicApiFp(configuration).listSimulationEnvironments(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List simulation runs
         * @param {number} sim_identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulationRuns(sim_identifier: number, options?: any) {
            return BasicApiFp(configuration).listSimulationRuns(sim_identifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List simulations
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(limit?: number, offset?: number, ordering?: string, options?: any) {
            return BasicApiFp(configuration).listSimulations(limit, offset, ordering, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List available stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStores(options?: any) {
            return BasicApiFp(configuration).listStores(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options?: any) {
            return BasicApiFp(configuration).listTags(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List user acounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts(options?: any) {
            return BasicApiFp(configuration).listUserAccounts(options)(fetch, basePath);
        },
        /**
         * 
         * @summary New bag comment
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {Comment} comment Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newBagComment(store_name: string, bag_name: string, comment: Comment, options?: any) {
            return BasicApiFp(configuration).newBagComment(store_name, bag_name, comment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Register new file
         * @param {string} store_name Name of the store
         * @param {FileDetailed} file The file metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newFile(store_name: string, file: FileDetailed, options?: any) {
            return BasicApiFp(configuration).newFile(store_name, file, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new session
         * @param {number} [valid_for] Validity in seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession(valid_for?: number, options?: any) {
            return BasicApiFp(configuration).newSession(valid_for, options)(fetch, basePath);
        },
        /**
         * 
         * @summary New simulation
         * @param {SimulationDetailed} simulation Simulation
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSimulation(simulation: SimulationDetailed, trigger?: string, options?: any) {
            return BasicApiFp(configuration).newSimulation(simulation, trigger, options)(fetch, basePath);
        },
        /**
         * 
         * @summary New simulation run
         * @param {number} sim_identifier 
         * @param {SimulationRunDetailed} simulation_run Simulation run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSimulationRun(sim_identifier: number, simulation_run: SimulationRunDetailed, options?: any) {
            return BasicApiFp(configuration).newSimulationRun(sim_identifier, simulation_run, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new task
         * @param {TaskDetailed} task The task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newTask(task: TaskDetailed, options?: any) {
            return BasicApiFp(configuration).newTask(task, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Partial update of bag information (this only supports a few fields)
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {any} bag Bag to register
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBagMeta(store_name: string, bag_name: string, bag: any, trigger?: string, options?: any) {
            return BasicApiFp(configuration).patchBagMeta(store_name, bag_name, bag, trigger, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Partial update of task (this only supports a few fields)
         * @param {string} task_identifier 
         * @param {any} task Fields to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTask(task_identifier: string, task: any, options?: any) {
            return BasicApiFp(configuration).patchTask(task_identifier, task, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/update bag information
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {BagDetailed} bag Bag to register
         * @param {string} [trigger] Hooks to trigger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBagMeta(store_name: string, bag_name: string, bag: BagDetailed, trigger?: string, options?: any) {
            return BasicApiFp(configuration).putBagMeta(store_name, bag_name, bag, trigger, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change bag tags
         * @param {string} store_name Name of the store
         * @param {string} bag_name Name of the bag
         * @param {Array&lt;string&gt;} tags List of tags
         * @param {boolean} [auto_create] Create non existing tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBagTags(store_name: string, bag_name: string, tags: Array<string>, auto_create?: boolean, options?: any) {
            return BasicApiFp(configuration).putBagTags(store_name, bag_name, tags, auto_create, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Write configuration key
         * @param {string} config_key Configuration key to read
         * @param {string} config_value Configuration key value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConfigurationKey(config_key: string, config_value: string, options?: any) {
            return BasicApiFp(configuration).putConfigurationKey(config_key, config_value, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change current user information
         * @param {User} user The user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrentUser(user: User, options?: any) {
            return BasicApiFp(configuration).putCurrentUser(user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/update configuration
         * @param {string} config_name Name of the configuration
         * @param {BagExtractionConfiguration} configuration_obj Configuration information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putExtractionConfiguration(config_name: string, configuration_obj: BagExtractionConfiguration, block_on_existing?: boolean, options?: any) {
            return BasicApiFp(configuration).putExtractionConfiguration(config_name, configuration_obj, block_on_existing, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {FileStore} store Store information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileStore(store_name: string, store: FileStore, block_on_existing?: boolean, options?: any) {
            return BasicApiFp(configuration).putFileStore(store_name, store, block_on_existing, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a simulation
         * @param {number} sim_identifier 
         * @param {SimulationDetailed} simulation Simulation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimulation(sim_identifier: number, simulation: SimulationDetailed, options?: any) {
            return BasicApiFp(configuration).putSimulation(sim_identifier, simulation, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/update a simulation environment
         * @param {string} env_name Name of the simulation environment
         * @param {SimulationEnvironmentDetailed} environment Simulation environment
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSimulationEnvironment(env_name: string, environment: SimulationEnvironmentDetailed, block_on_existing?: boolean, options?: any) {
            return BasicApiFp(configuration).putSimulationEnvironment(env_name, environment, block_on_existing, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {BagStoreDetailed} store Store information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStore(store_name: string, store: BagStoreDetailed, block_on_existing?: boolean, options?: any) {
            return BasicApiFp(configuration).putStore(store_name, store, block_on_existing, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/update store
         * @param {string} store_name Name of the store
         * @param {Array&lt;string&gt;} config_list List of config names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStoreExtractionConfigs(store_name: string, config_list: Array<string>, options?: any) {
            return BasicApiFp(configuration).putStoreExtractionConfigs(store_name, config_list, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/update tag
         * @param {string} tag Name of the tag
         * @param {Tag} tag_obj Tag information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTag(tag: string, tag_obj: Tag, options?: any) {
            return BasicApiFp(configuration).putTag(tag, tag_obj, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a task
         * @param {string} task_identifier 
         * @param {TaskDetailed} task The task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTask(task_identifier: string, task: TaskDetailed, options?: any) {
            return BasicApiFp(configuration).putTask(task_identifier, task, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change user information
         * @param {string} alias Alias of the user
         * @param {User} user The user information
         * @param {boolean} [block_on_existing] Only create a new one, block if one already exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserAccount(alias: string, user: User, block_on_existing?: boolean, options?: any) {
            return BasicApiFp(configuration).putUserAccount(alias, user, block_on_existing, options)(fetch, basePath);
        },
    };
};

/**
 * BasicApi - object-oriented interface
 * @export
 * @class BasicApi
 * @extends {BaseAPI}
 */
export class BasicApi extends BaseAPI {
    /**
     * 
     * @summary Authorization step forwarded to storage plugin
     * @param {} store_name Name of the store
     * @param {} step Step of the authorization procedure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public authorizeStepGet(store_name: string, step: string, options?: any) {
        return BasicApiFp(this.configuration).authorizeStepGet(store_name, step, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Authorization step forwarded to storage plugin
     * @param {} store_name Name of the store
     * @param {} step Step of the authorization procedure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public authorizeStepPost(store_name: string, step: string, options?: any) {
        return BasicApiFp(this.configuration).authorizeStepPost(store_name, step, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Authorization step forwarded to storage plugin
     * @param {} store_name Name of the store
     * @param {} step Step of the authorization procedure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public bagStoreAuthorizeStepGet(store_name: string, step: string, options?: any) {
        return BasicApiFp(this.configuration).bagStoreAuthorizeStepGet(store_name, step, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Authorization step forwarded to storage plugin
     * @param {} store_name Name of the store
     * @param {} step Step of the authorization procedure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public bagStoreAuthorizeStepPost(store_name: string, step: string, options?: any) {
        return BasicApiFp(this.configuration).bagStoreAuthorizeStepPost(store_name, step, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a comment
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {} comment_id Comment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteBagComment(store_name: string, bag_name: string, comment_id: number, options?: any) {
        return BasicApiFp(this.configuration).deleteBagComment(store_name, bag_name, comment_id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete extraction configuration
     * @param {} config_name Name of the configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteExtractionConfiguration(config_name: string, options?: any) {
        return BasicApiFp(this.configuration).deleteExtractionConfiguration(config_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete file store
     * @param {} store_name Name of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteFileStore(store_name: string, options?: any) {
        return BasicApiFp(this.configuration).deleteFileStore(store_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a session or sessions
     * @param {} session_id Session id or all or current
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteSession(session_id: string, options?: any) {
        return BasicApiFp(this.configuration).deleteSession(session_id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete simulation
     * @param {} sim_identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteSimulation(sim_identifier: number, options?: any) {
        return BasicApiFp(this.configuration).deleteSimulation(sim_identifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete simulation
     * @param {} env_name Name of the simulation environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteSimulationEnvironment(env_name: string, options?: any) {
        return BasicApiFp(this.configuration).deleteSimulationEnvironment(env_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete file store
     * @param {} store_name Name of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteStore(store_name: string, options?: any) {
        return BasicApiFp(this.configuration).deleteStore(store_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete user account
     * @param {} alias Alias of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public deleteUserAccount(alias: string, options?: any) {
        return BasicApiFp(this.configuration).deleteUserAccount(alias, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Take a task from the queue
     * @param {} worker_name Name of the worker trying to acquire a task
     * @param {} tasks Tasks that the worker can do (any or a list of tasks)
     * @param {} labels Labels the worker wants to do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public dequeueTask(worker_name: string, tasks: string, labels: string, options?: any) {
        return BasicApiFp(this.configuration).dequeueTask(worker_name, tasks, labels, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Perform an action on the task
     * @param {} task_identifier 
     * @param {} action Action to perform (cancel/prio_up)
     * @param {} [task] The task, required depending on the action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public doTaskAction(task_identifier: string, action: string, task?: TaskDetailed, options?: any) {
        return BasicApiFp(this.configuration).doTaskAction(task_identifier, action, task, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List comments from bag
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getBagComments(store_name: string, bag_name: string, options?: any) {
        return BasicApiFp(this.configuration).getBagComments(store_name, bag_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get rosbag
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getBagFile(store_name: string, bag_name: string, options?: any) {
        return BasicApiFp(this.configuration).getBagFile(store_name, bag_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List products from bag
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getBagMeta(store_name: string, bag_name: string, options?: any) {
        return BasicApiFp(this.configuration).getBagMeta(store_name, bag_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List tag from bag
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getBagTags(store_name: string, bag_name: string, options?: any) {
        return BasicApiFp(this.configuration).getBagTags(store_name, bag_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get configuration key
     * @param {} config_key Configuration key to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getConfigurationKey(config_key: string, options?: any) {
        return BasicApiFp(this.configuration).getConfigurationKey(config_key, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Endpoint that should be periodically triggered
     * @param {} [jobs] Specific cron jobs to trigger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getCronEndpoint(jobs?: string, options?: any) {
        return BasicApiFp(this.configuration).getCronEndpoint(jobs, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getCurrentUser(options?: any) {
        return BasicApiFp(this.configuration).getCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get configuration details
     * @param {} config_name Name of the configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getExtractionConfig(config_name: string, options?: any) {
        return BasicApiFp(this.configuration).getExtractionConfig(config_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get file
     * @param {} store_name Name of the store
     * @param {} uid Unique identifier of the file
     * @param {} file_name Name of the file
     * @param {} [no_redirect] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getFile(store_name: string, uid: number, file_name: string, no_redirect?: boolean, options?: any) {
        return BasicApiFp(this.configuration).getFile(store_name, uid, file_name, no_redirect, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get file meta data
     * @param {} store_name Name of the store
     * @param {} uid Unique identifier of the file
     * @param {} file_name Name of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getFileMeta(store_name: string, uid: number, file_name: string, options?: any) {
        return BasicApiFp(this.configuration).getFileMeta(store_name, uid, file_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get store details
     * @param {} store_name Name of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getFileStore(store_name: string, options?: any) {
        return BasicApiFp(this.configuration).getFileStore(store_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get simulation
     * @param {} sim_identifier 
     * @param {} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getSimulation(sim_identifier: number, expand?: boolean, options?: any) {
        return BasicApiFp(this.configuration).getSimulation(sim_identifier, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get simulation environment
     * @param {} env_name Name of the simulation environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getSimulationEnvironment(env_name: string, options?: any) {
        return BasicApiFp(this.configuration).getSimulationEnvironment(env_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get simulation run
     * @param {} sim_identifier 
     * @param {} run_identifier 
     * @param {} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getSimulationRun(sim_identifier: number, run_identifier: number, expand?: boolean, options?: any) {
        return BasicApiFp(this.configuration).getSimulationRun(sim_identifier, run_identifier, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get store details
     * @param {} store_name Name of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getStore(store_name: string, options?: any) {
        return BasicApiFp(this.configuration).getStore(store_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get list of auto extraction configs
     * @param {} store_name Name of the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getStoreExtractionConfigs(store_name: string, options?: any) {
        return BasicApiFp(this.configuration).getStoreExtractionConfigs(store_name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get tag info
     * @param {} tag Name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getTag(tag: string, options?: any) {
        return BasicApiFp(this.configuration).getTag(tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Take a task from the queue
     * @param {} task_identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getTask(task_identifier: string, options?: any) {
        return BasicApiFp(this.configuration).getTask(task_identifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user information
     * @param {} alias Alias of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public getUserAccount(alias: string, options?: any) {
        return BasicApiFp(this.configuration).getUserAccount(alias, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bags in store
     * @param {} store_name Name of the store
     * @param {} [limit] 
     * @param {} [offset] 
     * @param {} [ordering] 
     * @param {} [discovered_gte] 
     * @param {} [discovered_lte] 
     * @param {} [start_time_gte] 
     * @param {} [start_time_lte] 
     * @param {} [end_time_gte] 
     * @param {} [end_time_lte] 
     * @param {} [duration_gte] 
     * @param {} [duration_lte] 
     * @param {} [meta_available] 
     * @param {} [is_extracted] 
     * @param {} [name] 
     * @param {} [tags] 
     * @param {} [in_trash] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listBags(store_name: string, limit?: number, offset?: number, ordering?: string, discovered_gte?: Date, discovered_lte?: Date, start_time_gte?: Date, start_time_lte?: Date, end_time_gte?: Date, end_time_lte?: Date, duration_gte?: number, duration_lte?: number, meta_available?: boolean, is_extracted?: boolean, name?: string, tags?: string, in_trash?: boolean, options?: any) {
        return BasicApiFp(this.configuration).listBags(store_name, limit, offset, ordering, discovered_gte, discovered_lte, start_time_gte, start_time_lte, end_time_gte, end_time_lte, duration_gte, duration_lte, meta_available, is_extracted, name, tags, in_trash, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List available configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listExtractionConfigurations(options?: any) {
        return BasicApiFp(this.configuration).listExtractionConfigurations(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List available file stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listFileStores(options?: any) {
        return BasicApiFp(this.configuration).listFileStores(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List task queue
     * @param {} [limit] 
     * @param {} [offset] 
     * @param {} [ordering] 
     * @param {} [running] Include running tasks, default is true
     * @param {} [finished] Include finished tasks, default is true
     * @param {} [queued] Include queued tasks, default is true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listQueue(limit?: number, offset?: number, ordering?: string, running?: string, finished?: string, queued?: string, options?: any) {
        return BasicApiFp(this.configuration).listQueue(limit, offset, ordering, running, finished, queued, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listSessions(options?: any) {
        return BasicApiFp(this.configuration).listSessions(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List available simulation environments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listSimulationEnvironments(options?: any) {
        return BasicApiFp(this.configuration).listSimulationEnvironments(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List simulation runs
     * @param {} sim_identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listSimulationRuns(sim_identifier: number, options?: any) {
        return BasicApiFp(this.configuration).listSimulationRuns(sim_identifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List simulations
     * @param {} [limit] 
     * @param {} [offset] 
     * @param {} [ordering] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listSimulations(limit?: number, offset?: number, ordering?: string, options?: any) {
        return BasicApiFp(this.configuration).listSimulations(limit, offset, ordering, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List available stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listStores(options?: any) {
        return BasicApiFp(this.configuration).listStores(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listTags(options?: any) {
        return BasicApiFp(this.configuration).listTags(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List user acounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public listUserAccounts(options?: any) {
        return BasicApiFp(this.configuration).listUserAccounts(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary New bag comment
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {} comment Comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public newBagComment(store_name: string, bag_name: string, comment: Comment, options?: any) {
        return BasicApiFp(this.configuration).newBagComment(store_name, bag_name, comment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Register new file
     * @param {} store_name Name of the store
     * @param {} file The file metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public newFile(store_name: string, file: FileDetailed, options?: any) {
        return BasicApiFp(this.configuration).newFile(store_name, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new session
     * @param {} [valid_for] Validity in seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public newSession(valid_for?: number, options?: any) {
        return BasicApiFp(this.configuration).newSession(valid_for, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary New simulation
     * @param {} simulation Simulation
     * @param {} [trigger] Hooks to trigger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public newSimulation(simulation: SimulationDetailed, trigger?: string, options?: any) {
        return BasicApiFp(this.configuration).newSimulation(simulation, trigger, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary New simulation run
     * @param {} sim_identifier 
     * @param {} simulation_run Simulation run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public newSimulationRun(sim_identifier: number, simulation_run: SimulationRunDetailed, options?: any) {
        return BasicApiFp(this.configuration).newSimulationRun(sim_identifier, simulation_run, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new task
     * @param {} task The task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public newTask(task: TaskDetailed, options?: any) {
        return BasicApiFp(this.configuration).newTask(task, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Partial update of bag information (this only supports a few fields)
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {} bag Bag to register
     * @param {} [trigger] Hooks to trigger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public patchBagMeta(store_name: string, bag_name: string, bag: any, trigger?: string, options?: any) {
        return BasicApiFp(this.configuration).patchBagMeta(store_name, bag_name, bag, trigger, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Partial update of task (this only supports a few fields)
     * @param {} task_identifier 
     * @param {} task Fields to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public patchTask(task_identifier: string, task: any, options?: any) {
        return BasicApiFp(this.configuration).patchTask(task_identifier, task, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/update bag information
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {} bag Bag to register
     * @param {} [trigger] Hooks to trigger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putBagMeta(store_name: string, bag_name: string, bag: BagDetailed, trigger?: string, options?: any) {
        return BasicApiFp(this.configuration).putBagMeta(store_name, bag_name, bag, trigger, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Change bag tags
     * @param {} store_name Name of the store
     * @param {} bag_name Name of the bag
     * @param {} tags List of tags
     * @param {} [auto_create] Create non existing tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putBagTags(store_name: string, bag_name: string, tags: Array<string>, auto_create?: boolean, options?: any) {
        return BasicApiFp(this.configuration).putBagTags(store_name, bag_name, tags, auto_create, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Write configuration key
     * @param {} config_key Configuration key to read
     * @param {} config_value Configuration key value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putConfigurationKey(config_key: string, config_value: string, options?: any) {
        return BasicApiFp(this.configuration).putConfigurationKey(config_key, config_value, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Change current user information
     * @param {} user The user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putCurrentUser(user: User, options?: any) {
        return BasicApiFp(this.configuration).putCurrentUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/update configuration
     * @param {} config_name Name of the configuration
     * @param {} configuration_obj Configuration information
     * @param {} [block_on_existing] Only create a new one, block if one already exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putExtractionConfiguration(config_name: string, configuration_obj: BagExtractionConfiguration, block_on_existing?: boolean, options?: any) {
        return BasicApiFp(this.configuration).putExtractionConfiguration(config_name, configuration_obj, block_on_existing, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/update store
     * @param {} store_name Name of the store
     * @param {} store Store information
     * @param {} [block_on_existing] Only create a new one, block if one already exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putFileStore(store_name: string, store: FileStore, block_on_existing?: boolean, options?: any) {
        return BasicApiFp(this.configuration).putFileStore(store_name, store, block_on_existing, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a simulation
     * @param {} sim_identifier 
     * @param {} simulation Simulation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putSimulation(sim_identifier: number, simulation: SimulationDetailed, options?: any) {
        return BasicApiFp(this.configuration).putSimulation(sim_identifier, simulation, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/update a simulation environment
     * @param {} env_name Name of the simulation environment
     * @param {} environment Simulation environment
     * @param {} [block_on_existing] Only create a new one, block if one already exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putSimulationEnvironment(env_name: string, environment: SimulationEnvironmentDetailed, block_on_existing?: boolean, options?: any) {
        return BasicApiFp(this.configuration).putSimulationEnvironment(env_name, environment, block_on_existing, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/update store
     * @param {} store_name Name of the store
     * @param {} store Store information
     * @param {} [block_on_existing] Only create a new one, block if one already exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putStore(store_name: string, store: BagStoreDetailed, block_on_existing?: boolean, options?: any) {
        return BasicApiFp(this.configuration).putStore(store_name, store, block_on_existing, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/update store
     * @param {} store_name Name of the store
     * @param {} config_list List of config names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putStoreExtractionConfigs(store_name: string, config_list: Array<string>, options?: any) {
        return BasicApiFp(this.configuration).putStoreExtractionConfigs(store_name, config_list, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/update tag
     * @param {} tag Name of the tag
     * @param {} tag_obj Tag information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putTag(tag: string, tag_obj: Tag, options?: any) {
        return BasicApiFp(this.configuration).putTag(tag, tag_obj, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a task
     * @param {} task_identifier 
     * @param {} task The task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putTask(task_identifier: string, task: TaskDetailed, options?: any) {
        return BasicApiFp(this.configuration).putTask(task_identifier, task, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Change user information
     * @param {} alias Alias of the user
     * @param {} user The user information
     * @param {} [block_on_existing] Only create a new one, block if one already exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicApi
     */
    public putUserAccount(alias: string, user: User, block_on_existing?: boolean, options?: any) {
        return BasicApiFp(this.configuration).putUserAccount(alias, user, block_on_existing, options)(this.fetch, this.basePath);
    }

}

